using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using Microsoft.CodeAnalysis;

namespace VsctSourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class CommandTableSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<AdditionalText> vsctFiles = context.AdditionalTextsProvider.Where(
                static additionalText => additionalText.Path?.EndsWith(".vsct") ?? false);

            IncrementalValuesProvider<(string path, string text)> vsctPathAndText = vsctFiles.Select(
                static (additionalText, cancellationToken) =>
                {
                    string path = additionalText.Path;
                    string? text = additionalText.GetText(cancellationToken)?.ToString();
                    return (path, text);
                }).Where(pair => !string.IsNullOrEmpty(pair.text))!;

            IncrementalValuesProvider<(string path, CommandTable commandTable)> commandTables = vsctPathAndText.Select(
                (pathAndText, cancellationToken) =>
                {
                    XElement commandTable = XElement.Parse(pathAndText.text);
                    return (pathAndText.path, new CommandTable(commandTable));
                });

            IncrementalValueProvider<string> rootNamespace = context.AnalyzerConfigOptionsProvider.Select(
                static (analyzerConfigOptions, cancellationToken) =>
                {
                    analyzerConfigOptions.GlobalOptions.TryGetValue("build_property.RootNamespace", out string? value);
                    return value ?? "Unknown";
                });

            context.RegisterSourceOutput(
                commandTables.Combine(rootNamespace),
                (context, data) =>
                {
                    ((string path, CommandTable commandTable), string rootNamespace) = data;

                    (string key, Guid value)[] packageGuids = commandTable.Symbols
                        .SelectMany(static symbols => symbols.GuidSymbols.Select(guidSymbol => (key: guidSymbol.Name, value: guidSymbol.Value)))
                        .Where(pair => !string.IsNullOrEmpty(pair.key) && pair.value != Guid.Empty)
                        .ToArray();

                    (string name, int value)[] packageIds = commandTable.Symbols
                        .SelectMany(symbols => symbols.GuidSymbols.SelectMany(guidSymbol => guidSymbol.IDSymbols))
                        .Select(idSymbol => (name: idSymbol.Name, value: idSymbol.Value))
                        .Where(pair => !string.IsNullOrEmpty(pair.name))
                        .ToArray();

                    string generatedCode = $@"// <auto-generated/>

namespace {rootNamespace}
{{
    using System;

    /// <summary>
    /// Helper class that exposes all GUIDs used across VS Package.
    /// </summary>
    internal sealed partial class PackageGuids
    {{
{string.Join("\r\n\r\n", packageGuids.Select(pair => $@"        public const string {pair.key}String = ""{pair.value:d}"";
        public static Guid {pair.key} = new Guid({pair.key}String);"))}
    }}
    /// <summary>
    /// Helper class that encapsulates all CommandIDs uses across VS Package.
    /// </summary>
    internal sealed partial class PackageIds
    {{
{string.Join("\r\n", packageIds.Select(pair => $@"        public const int {pair.name} = 0x{pair.value:X4};"))}
    }}
}}";

                    string? hintName = Path.GetFileNameWithoutExtension(path) + ".g.cs";
                    context.AddSource(hintName, generatedCode);
                });
        }
    }
}