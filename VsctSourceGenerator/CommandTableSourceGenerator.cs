using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;
using Microsoft.CodeAnalysis;

namespace VsctSourceGenerator
{
    [Generator(LanguageNames.CSharp)]
    public class CommandTableSourceGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            IncrementalValuesProvider<AdditionalText> vsctFiles = context.AdditionalTextsProvider.Where(
                static additionalText => additionalText.Path?.EndsWith(".vsct") ?? false);

            IncrementalValueProvider<string> rootNamespace = context.AnalyzerConfigOptionsProvider.Select(
                static (analyzerConfigOptions, cancellationToken) =>
                {
                    analyzerConfigOptions.GlobalOptions.TryGetValue("build_property.RootNamespace", out string? value);
                    return value ?? "Unknown";
                });

            context.RegisterSourceOutput(
                vsctFiles.Combine(rootNamespace),
                (context, data) =>
                {
                    AdditionalText vsct = data.Left;
                    string? text = vsct.GetText(context.CancellationToken)?.ToString();
                    if (text is null)
                        return;

                    string rootNamespace = data.Right;

                    List<(string key, Guid value)>? packageGuids = new();
                    List<(string name, string value)>? packageIds = new();

                    XElement commandTable = XElement.Parse(text);
                    XmlNamespaceManager resolver = new(new NameTable());
                    resolver.AddNamespace("ct", "http://schemas.microsoft.com/VisualStudio/2005-10-18/CommandTable");
                    IEnumerable<XElement> symbols = commandTable.XPathSelectElements("/ct:Symbols/ct:GuidSymbol", resolver);
                    foreach (XElement symbol in symbols)
                    {
                        string? name = symbol.Attribute("name")?.Value;
                        string? value = symbol.Attribute("value")?.Value;
                        if (name is null || !Guid.TryParse(value, out Guid guid))
                            continue;

                        packageGuids.Add((name, guid));
                        foreach (XElement idSymbol in symbol.XPathSelectElements("ct:IDSymbol", resolver))
                        {
                            string? idName = idSymbol.Attribute("name")?.Value;
                            string? idValue = idSymbol.Attribute("value")?.Value;
                            if (idName is null || idValue is null)
                                continue;

                            packageIds.Add((idName, idValue));
                        }
                    }

                    string generatedCode = $@"// <auto-generated/>

namespace {rootNamespace}
{{
    using System;

    /// <summary>
    /// Helper class that exposes all GUIDs used across VS Package.
    /// </summary>
    internal sealed partial class PackageGuids
    {{
{string.Join("\r\n\r\n", packageGuids.Select(pair => $@"        public const string {pair.key}String = ""{pair.value:d}"";
        public static Guid {pair.key} = new Guid({pair.key}String);"))}
    }}
    /// <summary>
    /// Helper class that encapsulates all CommandIDs uses across VS Package.
    /// </summary>
    internal sealed partial class PackageIds
    {{
{string.Join("\r\n", packageIds.Select(pair => $@"        public const int {pair.name} = {pair.value};"))}
    }}
}}";

                    string? hintName = Path.GetFileNameWithoutExtension(vsct.Path) + ".g.cs";
                    context.AddSource(hintName, generatedCode);
                });
        }
    }
}